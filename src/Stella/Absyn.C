/* File generated by the BNF Converter (bnfc 2.9.4.1). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"
namespace Stella
{
/********************   AProgram    ********************/
AProgram::AProgram(LanguageDecl *p1, ListExtension *p2, ListDecl *p3)
{
  languagedecl_ = p1;
  listextension_ = p2;
  listdecl_ = p3;

}

AProgram::AProgram(const AProgram & other)
{
  languagedecl_ = other.languagedecl_->clone();
  listextension_ = other.listextension_->clone();
  listdecl_ = other.listdecl_->clone();

}

AProgram &AProgram::operator=(const AProgram & other)
{
  AProgram tmp(other);
  swap(tmp);
  return *this;
}

void AProgram::swap(AProgram & other)
{
  std::swap(languagedecl_, other.languagedecl_);
  std::swap(listextension_, other.listextension_);
  std::swap(listdecl_, other.listdecl_);

}

AProgram::~AProgram()
{
  delete(languagedecl_);
  delete(listextension_);
  delete(listdecl_);

}

void AProgram::accept(Visitor *v)
{
  v->visitAProgram(this);
}

AProgram *AProgram::clone() const
{
  return new AProgram(*this);
}



/********************   LanguageCore    ********************/
LanguageCore::LanguageCore()
{

}

LanguageCore::LanguageCore(const LanguageCore & other)
{

}

LanguageCore &LanguageCore::operator=(const LanguageCore & other)
{
  LanguageCore tmp(other);
  swap(tmp);
  return *this;
}

void LanguageCore::swap(LanguageCore & other)
{

}

LanguageCore::~LanguageCore()
{

}

void LanguageCore::accept(Visitor *v)
{
  v->visitLanguageCore(this);
}

LanguageCore *LanguageCore::clone() const
{
  return new LanguageCore(*this);
}



/********************   AnExtension    ********************/
AnExtension::AnExtension(ListExtensionName *p1)
{
  listextensionname_ = p1;

}

AnExtension::AnExtension(const AnExtension & other)
{
  listextensionname_ = other.listextensionname_->clone();

}

AnExtension &AnExtension::operator=(const AnExtension & other)
{
  AnExtension tmp(other);
  swap(tmp);
  return *this;
}

void AnExtension::swap(AnExtension & other)
{
  std::swap(listextensionname_, other.listextensionname_);

}

AnExtension::~AnExtension()
{
  delete(listextensionname_);

}

void AnExtension::accept(Visitor *v)
{
  v->visitAnExtension(this);
}

AnExtension *AnExtension::clone() const
{
  return new AnExtension(*this);
}



/********************   DeclFun    ********************/
DeclFun::DeclFun(ListAnnotation *p1, StellaIdent p2, ListParamDecl *p3, ReturnType *p4, ThrowType *p5, ListDecl *p6, Expr *p7)
{
  listannotation_ = p1;
  stellaident_ = p2;
  listparamdecl_ = p3;
  returntype_ = p4;
  throwtype_ = p5;
  listdecl_ = p6;
  expr_ = p7;

}

DeclFun::DeclFun(const DeclFun & other)
{
  listannotation_ = other.listannotation_->clone();
  stellaident_ = other.stellaident_;
  listparamdecl_ = other.listparamdecl_->clone();
  returntype_ = other.returntype_->clone();
  throwtype_ = other.throwtype_->clone();
  listdecl_ = other.listdecl_->clone();
  expr_ = other.expr_->clone();

}

DeclFun &DeclFun::operator=(const DeclFun & other)
{
  DeclFun tmp(other);
  swap(tmp);
  return *this;
}

void DeclFun::swap(DeclFun & other)
{
  std::swap(listannotation_, other.listannotation_);
  std::swap(stellaident_, other.stellaident_);
  std::swap(listparamdecl_, other.listparamdecl_);
  std::swap(returntype_, other.returntype_);
  std::swap(throwtype_, other.throwtype_);
  std::swap(listdecl_, other.listdecl_);
  std::swap(expr_, other.expr_);

}

DeclFun::~DeclFun()
{
  delete(listannotation_);
  delete(listparamdecl_);
  delete(returntype_);
  delete(throwtype_);
  delete(listdecl_);
  delete(expr_);

}

void DeclFun::accept(Visitor *v)
{
  v->visitDeclFun(this);
}

DeclFun *DeclFun::clone() const
{
  return new DeclFun(*this);
}



/********************   DeclTypeAlias    ********************/
DeclTypeAlias::DeclTypeAlias(StellaIdent p1, Type *p2)
{
  stellaident_ = p1;
  type_ = p2;

}

DeclTypeAlias::DeclTypeAlias(const DeclTypeAlias & other)
{
  stellaident_ = other.stellaident_;
  type_ = other.type_->clone();

}

DeclTypeAlias &DeclTypeAlias::operator=(const DeclTypeAlias & other)
{
  DeclTypeAlias tmp(other);
  swap(tmp);
  return *this;
}

void DeclTypeAlias::swap(DeclTypeAlias & other)
{
  std::swap(stellaident_, other.stellaident_);
  std::swap(type_, other.type_);

}

DeclTypeAlias::~DeclTypeAlias()
{
  delete(type_);

}

void DeclTypeAlias::accept(Visitor *v)
{
  v->visitDeclTypeAlias(this);
}

DeclTypeAlias *DeclTypeAlias::clone() const
{
  return new DeclTypeAlias(*this);
}



/********************   ALocalDecl    ********************/
ALocalDecl::ALocalDecl(Decl *p1)
{
  decl_ = p1;

}

ALocalDecl::ALocalDecl(const ALocalDecl & other)
{
  decl_ = other.decl_->clone();

}

ALocalDecl &ALocalDecl::operator=(const ALocalDecl & other)
{
  ALocalDecl tmp(other);
  swap(tmp);
  return *this;
}

void ALocalDecl::swap(ALocalDecl & other)
{
  std::swap(decl_, other.decl_);

}

ALocalDecl::~ALocalDecl()
{
  delete(decl_);

}

void ALocalDecl::accept(Visitor *v)
{
  v->visitALocalDecl(this);
}

ALocalDecl *ALocalDecl::clone() const
{
  return new ALocalDecl(*this);
}



/********************   InlineAnnotation    ********************/
InlineAnnotation::InlineAnnotation()
{

}

InlineAnnotation::InlineAnnotation(const InlineAnnotation & other)
{

}

InlineAnnotation &InlineAnnotation::operator=(const InlineAnnotation & other)
{
  InlineAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void InlineAnnotation::swap(InlineAnnotation & other)
{

}

InlineAnnotation::~InlineAnnotation()
{

}

void InlineAnnotation::accept(Visitor *v)
{
  v->visitInlineAnnotation(this);
}

InlineAnnotation *InlineAnnotation::clone() const
{
  return new InlineAnnotation(*this);
}



/********************   AParamDecl    ********************/
AParamDecl::AParamDecl(StellaIdent p1, Type *p2)
{
  stellaident_ = p1;
  type_ = p2;

}

AParamDecl::AParamDecl(const AParamDecl & other)
{
  stellaident_ = other.stellaident_;
  type_ = other.type_->clone();

}

AParamDecl &AParamDecl::operator=(const AParamDecl & other)
{
  AParamDecl tmp(other);
  swap(tmp);
  return *this;
}

void AParamDecl::swap(AParamDecl & other)
{
  std::swap(stellaident_, other.stellaident_);
  std::swap(type_, other.type_);

}

AParamDecl::~AParamDecl()
{
  delete(type_);

}

void AParamDecl::accept(Visitor *v)
{
  v->visitAParamDecl(this);
}

AParamDecl *AParamDecl::clone() const
{
  return new AParamDecl(*this);
}



/********************   NoReturnType    ********************/
NoReturnType::NoReturnType()
{

}

NoReturnType::NoReturnType(const NoReturnType & other)
{

}

NoReturnType &NoReturnType::operator=(const NoReturnType & other)
{
  NoReturnType tmp(other);
  swap(tmp);
  return *this;
}

void NoReturnType::swap(NoReturnType & other)
{

}

NoReturnType::~NoReturnType()
{

}

void NoReturnType::accept(Visitor *v)
{
  v->visitNoReturnType(this);
}

NoReturnType *NoReturnType::clone() const
{
  return new NoReturnType(*this);
}



/********************   SomeReturnType    ********************/
SomeReturnType::SomeReturnType(Type *p1)
{
  type_ = p1;

}

SomeReturnType::SomeReturnType(const SomeReturnType & other)
{
  type_ = other.type_->clone();

}

SomeReturnType &SomeReturnType::operator=(const SomeReturnType & other)
{
  SomeReturnType tmp(other);
  swap(tmp);
  return *this;
}

void SomeReturnType::swap(SomeReturnType & other)
{
  std::swap(type_, other.type_);

}

SomeReturnType::~SomeReturnType()
{
  delete(type_);

}

void SomeReturnType::accept(Visitor *v)
{
  v->visitSomeReturnType(this);
}

SomeReturnType *SomeReturnType::clone() const
{
  return new SomeReturnType(*this);
}



/********************   NoThrowType    ********************/
NoThrowType::NoThrowType()
{

}

NoThrowType::NoThrowType(const NoThrowType & other)
{

}

NoThrowType &NoThrowType::operator=(const NoThrowType & other)
{
  NoThrowType tmp(other);
  swap(tmp);
  return *this;
}

void NoThrowType::swap(NoThrowType & other)
{

}

NoThrowType::~NoThrowType()
{

}

void NoThrowType::accept(Visitor *v)
{
  v->visitNoThrowType(this);
}

NoThrowType *NoThrowType::clone() const
{
  return new NoThrowType(*this);
}



/********************   SomeThrowType    ********************/
SomeThrowType::SomeThrowType(ListType *p1)
{
  listtype_ = p1;

}

SomeThrowType::SomeThrowType(const SomeThrowType & other)
{
  listtype_ = other.listtype_->clone();

}

SomeThrowType &SomeThrowType::operator=(const SomeThrowType & other)
{
  SomeThrowType tmp(other);
  swap(tmp);
  return *this;
}

void SomeThrowType::swap(SomeThrowType & other)
{
  std::swap(listtype_, other.listtype_);

}

SomeThrowType::~SomeThrowType()
{
  delete(listtype_);

}

void SomeThrowType::accept(Visitor *v)
{
  v->visitSomeThrowType(this);
}

SomeThrowType *SomeThrowType::clone() const
{
  return new SomeThrowType(*this);
}



/********************   TypeFun    ********************/
TypeFun::TypeFun(ListType *p1, Type *p2)
{
  listtype_ = p1;
  type_ = p2;

}

TypeFun::TypeFun(const TypeFun & other)
{
  listtype_ = other.listtype_->clone();
  type_ = other.type_->clone();

}

TypeFun &TypeFun::operator=(const TypeFun & other)
{
  TypeFun tmp(other);
  swap(tmp);
  return *this;
}

void TypeFun::swap(TypeFun & other)
{
  std::swap(listtype_, other.listtype_);
  std::swap(type_, other.type_);

}

TypeFun::~TypeFun()
{
  delete(listtype_);
  delete(type_);

}

void TypeFun::accept(Visitor *v)
{
  v->visitTypeFun(this);
}

TypeFun *TypeFun::clone() const
{
  return new TypeFun(*this);
}



/********************   TypeRec    ********************/
TypeRec::TypeRec(StellaIdent p1, Type *p2)
{
  stellaident_ = p1;
  type_ = p2;

}

TypeRec::TypeRec(const TypeRec & other)
{
  stellaident_ = other.stellaident_;
  type_ = other.type_->clone();

}

TypeRec &TypeRec::operator=(const TypeRec & other)
{
  TypeRec tmp(other);
  swap(tmp);
  return *this;
}

void TypeRec::swap(TypeRec & other)
{
  std::swap(stellaident_, other.stellaident_);
  std::swap(type_, other.type_);

}

TypeRec::~TypeRec()
{
  delete(type_);

}

void TypeRec::accept(Visitor *v)
{
  v->visitTypeRec(this);
}

TypeRec *TypeRec::clone() const
{
  return new TypeRec(*this);
}



/********************   TypeSum    ********************/
TypeSum::TypeSum(Type *p1, Type *p2)
{
  type_1 = p1;
  type_2 = p2;

}

TypeSum::TypeSum(const TypeSum & other)
{
  type_1 = other.type_1->clone();
  type_2 = other.type_2->clone();

}

TypeSum &TypeSum::operator=(const TypeSum & other)
{
  TypeSum tmp(other);
  swap(tmp);
  return *this;
}

void TypeSum::swap(TypeSum & other)
{
  std::swap(type_1, other.type_1);
  std::swap(type_2, other.type_2);

}

TypeSum::~TypeSum()
{
  delete(type_1);
  delete(type_2);

}

void TypeSum::accept(Visitor *v)
{
  v->visitTypeSum(this);
}

TypeSum *TypeSum::clone() const
{
  return new TypeSum(*this);
}



/********************   TypeTuple    ********************/
TypeTuple::TypeTuple(ListType *p1)
{
  listtype_ = p1;

}

TypeTuple::TypeTuple(const TypeTuple & other)
{
  listtype_ = other.listtype_->clone();

}

TypeTuple &TypeTuple::operator=(const TypeTuple & other)
{
  TypeTuple tmp(other);
  swap(tmp);
  return *this;
}

void TypeTuple::swap(TypeTuple & other)
{
  std::swap(listtype_, other.listtype_);

}

TypeTuple::~TypeTuple()
{
  delete(listtype_);

}

void TypeTuple::accept(Visitor *v)
{
  v->visitTypeTuple(this);
}

TypeTuple *TypeTuple::clone() const
{
  return new TypeTuple(*this);
}



/********************   TypeRecord    ********************/
TypeRecord::TypeRecord(ListRecordFieldType *p1)
{
  listrecordfieldtype_ = p1;

}

TypeRecord::TypeRecord(const TypeRecord & other)
{
  listrecordfieldtype_ = other.listrecordfieldtype_->clone();

}

TypeRecord &TypeRecord::operator=(const TypeRecord & other)
{
  TypeRecord tmp(other);
  swap(tmp);
  return *this;
}

void TypeRecord::swap(TypeRecord & other)
{
  std::swap(listrecordfieldtype_, other.listrecordfieldtype_);

}

TypeRecord::~TypeRecord()
{
  delete(listrecordfieldtype_);

}

void TypeRecord::accept(Visitor *v)
{
  v->visitTypeRecord(this);
}

TypeRecord *TypeRecord::clone() const
{
  return new TypeRecord(*this);
}



/********************   TypeVariant    ********************/
TypeVariant::TypeVariant(ListVariantFieldType *p1)
{
  listvariantfieldtype_ = p1;

}

TypeVariant::TypeVariant(const TypeVariant & other)
{
  listvariantfieldtype_ = other.listvariantfieldtype_->clone();

}

TypeVariant &TypeVariant::operator=(const TypeVariant & other)
{
  TypeVariant tmp(other);
  swap(tmp);
  return *this;
}

void TypeVariant::swap(TypeVariant & other)
{
  std::swap(listvariantfieldtype_, other.listvariantfieldtype_);

}

TypeVariant::~TypeVariant()
{
  delete(listvariantfieldtype_);

}

void TypeVariant::accept(Visitor *v)
{
  v->visitTypeVariant(this);
}

TypeVariant *TypeVariant::clone() const
{
  return new TypeVariant(*this);
}



/********************   TypeList    ********************/
TypeList::TypeList(Type *p1)
{
  type_ = p1;

}

TypeList::TypeList(const TypeList & other)
{
  type_ = other.type_->clone();

}

TypeList &TypeList::operator=(const TypeList & other)
{
  TypeList tmp(other);
  swap(tmp);
  return *this;
}

void TypeList::swap(TypeList & other)
{
  std::swap(type_, other.type_);

}

TypeList::~TypeList()
{
  delete(type_);

}

void TypeList::accept(Visitor *v)
{
  v->visitTypeList(this);
}

TypeList *TypeList::clone() const
{
  return new TypeList(*this);
}



/********************   TypeBool    ********************/
TypeBool::TypeBool()
{

}

TypeBool::TypeBool(const TypeBool & other)
{

}

TypeBool &TypeBool::operator=(const TypeBool & other)
{
  TypeBool tmp(other);
  swap(tmp);
  return *this;
}

void TypeBool::swap(TypeBool & other)
{

}

TypeBool::~TypeBool()
{

}

void TypeBool::accept(Visitor *v)
{
  v->visitTypeBool(this);
}

TypeBool *TypeBool::clone() const
{
  return new TypeBool(*this);
}



/********************   TypeNat    ********************/
TypeNat::TypeNat()
{

}

TypeNat::TypeNat(const TypeNat & other)
{

}

TypeNat &TypeNat::operator=(const TypeNat & other)
{
  TypeNat tmp(other);
  swap(tmp);
  return *this;
}

void TypeNat::swap(TypeNat & other)
{

}

TypeNat::~TypeNat()
{

}

void TypeNat::accept(Visitor *v)
{
  v->visitTypeNat(this);
}

TypeNat *TypeNat::clone() const
{
  return new TypeNat(*this);
}



/********************   TypeUnit    ********************/
TypeUnit::TypeUnit()
{

}

TypeUnit::TypeUnit(const TypeUnit & other)
{

}

TypeUnit &TypeUnit::operator=(const TypeUnit & other)
{
  TypeUnit tmp(other);
  swap(tmp);
  return *this;
}

void TypeUnit::swap(TypeUnit & other)
{

}

TypeUnit::~TypeUnit()
{

}

void TypeUnit::accept(Visitor *v)
{
  v->visitTypeUnit(this);
}

TypeUnit *TypeUnit::clone() const
{
  return new TypeUnit(*this);
}



/********************   TypeVar    ********************/
TypeVar::TypeVar(StellaIdent p1)
{
  stellaident_ = p1;

}

TypeVar::TypeVar(const TypeVar & other)
{
  stellaident_ = other.stellaident_;

}

TypeVar &TypeVar::operator=(const TypeVar & other)
{
  TypeVar tmp(other);
  swap(tmp);
  return *this;
}

void TypeVar::swap(TypeVar & other)
{
  std::swap(stellaident_, other.stellaident_);

}

TypeVar::~TypeVar()
{

}

void TypeVar::accept(Visitor *v)
{
  v->visitTypeVar(this);
}

TypeVar *TypeVar::clone() const
{
  return new TypeVar(*this);
}



/********************   AMatchCase    ********************/
AMatchCase::AMatchCase(Pattern *p1, Expr *p2)
{
  pattern_ = p1;
  expr_ = p2;

}

AMatchCase::AMatchCase(const AMatchCase & other)
{
  pattern_ = other.pattern_->clone();
  expr_ = other.expr_->clone();

}

AMatchCase &AMatchCase::operator=(const AMatchCase & other)
{
  AMatchCase tmp(other);
  swap(tmp);
  return *this;
}

void AMatchCase::swap(AMatchCase & other)
{
  std::swap(pattern_, other.pattern_);
  std::swap(expr_, other.expr_);

}

AMatchCase::~AMatchCase()
{
  delete(pattern_);
  delete(expr_);

}

void AMatchCase::accept(Visitor *v)
{
  v->visitAMatchCase(this);
}

AMatchCase *AMatchCase::clone() const
{
  return new AMatchCase(*this);
}



/********************   NoTyping    ********************/
NoTyping::NoTyping()
{

}

NoTyping::NoTyping(const NoTyping & other)
{

}

NoTyping &NoTyping::operator=(const NoTyping & other)
{
  NoTyping tmp(other);
  swap(tmp);
  return *this;
}

void NoTyping::swap(NoTyping & other)
{

}

NoTyping::~NoTyping()
{

}

void NoTyping::accept(Visitor *v)
{
  v->visitNoTyping(this);
}

NoTyping *NoTyping::clone() const
{
  return new NoTyping(*this);
}



/********************   SomeTyping    ********************/
SomeTyping::SomeTyping(Type *p1)
{
  type_ = p1;

}

SomeTyping::SomeTyping(const SomeTyping & other)
{
  type_ = other.type_->clone();

}

SomeTyping &SomeTyping::operator=(const SomeTyping & other)
{
  SomeTyping tmp(other);
  swap(tmp);
  return *this;
}

void SomeTyping::swap(SomeTyping & other)
{
  std::swap(type_, other.type_);

}

SomeTyping::~SomeTyping()
{
  delete(type_);

}

void SomeTyping::accept(Visitor *v)
{
  v->visitSomeTyping(this);
}

SomeTyping *SomeTyping::clone() const
{
  return new SomeTyping(*this);
}



/********************   NoPatternData    ********************/
NoPatternData::NoPatternData()
{

}

NoPatternData::NoPatternData(const NoPatternData & other)
{

}

NoPatternData &NoPatternData::operator=(const NoPatternData & other)
{
  NoPatternData tmp(other);
  swap(tmp);
  return *this;
}

void NoPatternData::swap(NoPatternData & other)
{

}

NoPatternData::~NoPatternData()
{

}

void NoPatternData::accept(Visitor *v)
{
  v->visitNoPatternData(this);
}

NoPatternData *NoPatternData::clone() const
{
  return new NoPatternData(*this);
}



/********************   SomePatternData    ********************/
SomePatternData::SomePatternData(Pattern *p1)
{
  pattern_ = p1;

}

SomePatternData::SomePatternData(const SomePatternData & other)
{
  pattern_ = other.pattern_->clone();

}

SomePatternData &SomePatternData::operator=(const SomePatternData & other)
{
  SomePatternData tmp(other);
  swap(tmp);
  return *this;
}

void SomePatternData::swap(SomePatternData & other)
{
  std::swap(pattern_, other.pattern_);

}

SomePatternData::~SomePatternData()
{
  delete(pattern_);

}

void SomePatternData::accept(Visitor *v)
{
  v->visitSomePatternData(this);
}

SomePatternData *SomePatternData::clone() const
{
  return new SomePatternData(*this);
}



/********************   NoExprData    ********************/
NoExprData::NoExprData()
{

}

NoExprData::NoExprData(const NoExprData & other)
{

}

NoExprData &NoExprData::operator=(const NoExprData & other)
{
  NoExprData tmp(other);
  swap(tmp);
  return *this;
}

void NoExprData::swap(NoExprData & other)
{

}

NoExprData::~NoExprData()
{

}

void NoExprData::accept(Visitor *v)
{
  v->visitNoExprData(this);
}

NoExprData *NoExprData::clone() const
{
  return new NoExprData(*this);
}



/********************   SomeExprData    ********************/
SomeExprData::SomeExprData(Expr *p1)
{
  expr_ = p1;

}

SomeExprData::SomeExprData(const SomeExprData & other)
{
  expr_ = other.expr_->clone();

}

SomeExprData &SomeExprData::operator=(const SomeExprData & other)
{
  SomeExprData tmp(other);
  swap(tmp);
  return *this;
}

void SomeExprData::swap(SomeExprData & other)
{
  std::swap(expr_, other.expr_);

}

SomeExprData::~SomeExprData()
{
  delete(expr_);

}

void SomeExprData::accept(Visitor *v)
{
  v->visitSomeExprData(this);
}

SomeExprData *SomeExprData::clone() const
{
  return new SomeExprData(*this);
}



/********************   PatternVariant    ********************/
PatternVariant::PatternVariant(StellaIdent p1, PatternData *p2)
{
  stellaident_ = p1;
  patterndata_ = p2;

}

PatternVariant::PatternVariant(const PatternVariant & other)
{
  stellaident_ = other.stellaident_;
  patterndata_ = other.patterndata_->clone();

}

PatternVariant &PatternVariant::operator=(const PatternVariant & other)
{
  PatternVariant tmp(other);
  swap(tmp);
  return *this;
}

void PatternVariant::swap(PatternVariant & other)
{
  std::swap(stellaident_, other.stellaident_);
  std::swap(patterndata_, other.patterndata_);

}

PatternVariant::~PatternVariant()
{
  delete(patterndata_);

}

void PatternVariant::accept(Visitor *v)
{
  v->visitPatternVariant(this);
}

PatternVariant *PatternVariant::clone() const
{
  return new PatternVariant(*this);
}



/********************   PatternInl    ********************/
PatternInl::PatternInl(Pattern *p1)
{
  pattern_ = p1;

}

PatternInl::PatternInl(const PatternInl & other)
{
  pattern_ = other.pattern_->clone();

}

PatternInl &PatternInl::operator=(const PatternInl & other)
{
  PatternInl tmp(other);
  swap(tmp);
  return *this;
}

void PatternInl::swap(PatternInl & other)
{
  std::swap(pattern_, other.pattern_);

}

PatternInl::~PatternInl()
{
  delete(pattern_);

}

void PatternInl::accept(Visitor *v)
{
  v->visitPatternInl(this);
}

PatternInl *PatternInl::clone() const
{
  return new PatternInl(*this);
}



/********************   PatternInr    ********************/
PatternInr::PatternInr(Pattern *p1)
{
  pattern_ = p1;

}

PatternInr::PatternInr(const PatternInr & other)
{
  pattern_ = other.pattern_->clone();

}

PatternInr &PatternInr::operator=(const PatternInr & other)
{
  PatternInr tmp(other);
  swap(tmp);
  return *this;
}

void PatternInr::swap(PatternInr & other)
{
  std::swap(pattern_, other.pattern_);

}

PatternInr::~PatternInr()
{
  delete(pattern_);

}

void PatternInr::accept(Visitor *v)
{
  v->visitPatternInr(this);
}

PatternInr *PatternInr::clone() const
{
  return new PatternInr(*this);
}



/********************   PatternTuple    ********************/
PatternTuple::PatternTuple(ListPattern *p1)
{
  listpattern_ = p1;

}

PatternTuple::PatternTuple(const PatternTuple & other)
{
  listpattern_ = other.listpattern_->clone();

}

PatternTuple &PatternTuple::operator=(const PatternTuple & other)
{
  PatternTuple tmp(other);
  swap(tmp);
  return *this;
}

void PatternTuple::swap(PatternTuple & other)
{
  std::swap(listpattern_, other.listpattern_);

}

PatternTuple::~PatternTuple()
{
  delete(listpattern_);

}

void PatternTuple::accept(Visitor *v)
{
  v->visitPatternTuple(this);
}

PatternTuple *PatternTuple::clone() const
{
  return new PatternTuple(*this);
}



/********************   PatternRecord    ********************/
PatternRecord::PatternRecord(ListLabelledPattern *p1)
{
  listlabelledpattern_ = p1;

}

PatternRecord::PatternRecord(const PatternRecord & other)
{
  listlabelledpattern_ = other.listlabelledpattern_->clone();

}

PatternRecord &PatternRecord::operator=(const PatternRecord & other)
{
  PatternRecord tmp(other);
  swap(tmp);
  return *this;
}

void PatternRecord::swap(PatternRecord & other)
{
  std::swap(listlabelledpattern_, other.listlabelledpattern_);

}

PatternRecord::~PatternRecord()
{
  delete(listlabelledpattern_);

}

void PatternRecord::accept(Visitor *v)
{
  v->visitPatternRecord(this);
}

PatternRecord *PatternRecord::clone() const
{
  return new PatternRecord(*this);
}



/********************   PatternList    ********************/
PatternList::PatternList(ListPattern *p1)
{
  listpattern_ = p1;

}

PatternList::PatternList(const PatternList & other)
{
  listpattern_ = other.listpattern_->clone();

}

PatternList &PatternList::operator=(const PatternList & other)
{
  PatternList tmp(other);
  swap(tmp);
  return *this;
}

void PatternList::swap(PatternList & other)
{
  std::swap(listpattern_, other.listpattern_);

}

PatternList::~PatternList()
{
  delete(listpattern_);

}

void PatternList::accept(Visitor *v)
{
  v->visitPatternList(this);
}

PatternList *PatternList::clone() const
{
  return new PatternList(*this);
}



/********************   PatternCons    ********************/
PatternCons::PatternCons(Pattern *p1, Pattern *p2)
{
  pattern_1 = p1;
  pattern_2 = p2;

}

PatternCons::PatternCons(const PatternCons & other)
{
  pattern_1 = other.pattern_1->clone();
  pattern_2 = other.pattern_2->clone();

}

PatternCons &PatternCons::operator=(const PatternCons & other)
{
  PatternCons tmp(other);
  swap(tmp);
  return *this;
}

void PatternCons::swap(PatternCons & other)
{
  std::swap(pattern_1, other.pattern_1);
  std::swap(pattern_2, other.pattern_2);

}

PatternCons::~PatternCons()
{
  delete(pattern_1);
  delete(pattern_2);

}

void PatternCons::accept(Visitor *v)
{
  v->visitPatternCons(this);
}

PatternCons *PatternCons::clone() const
{
  return new PatternCons(*this);
}



/********************   PatternFalse    ********************/
PatternFalse::PatternFalse()
{

}

PatternFalse::PatternFalse(const PatternFalse & other)
{

}

PatternFalse &PatternFalse::operator=(const PatternFalse & other)
{
  PatternFalse tmp(other);
  swap(tmp);
  return *this;
}

void PatternFalse::swap(PatternFalse & other)
{

}

PatternFalse::~PatternFalse()
{

}

void PatternFalse::accept(Visitor *v)
{
  v->visitPatternFalse(this);
}

PatternFalse *PatternFalse::clone() const
{
  return new PatternFalse(*this);
}



/********************   PatternTrue    ********************/
PatternTrue::PatternTrue()
{

}

PatternTrue::PatternTrue(const PatternTrue & other)
{

}

PatternTrue &PatternTrue::operator=(const PatternTrue & other)
{
  PatternTrue tmp(other);
  swap(tmp);
  return *this;
}

void PatternTrue::swap(PatternTrue & other)
{

}

PatternTrue::~PatternTrue()
{

}

void PatternTrue::accept(Visitor *v)
{
  v->visitPatternTrue(this);
}

PatternTrue *PatternTrue::clone() const
{
  return new PatternTrue(*this);
}



/********************   PatternUnit    ********************/
PatternUnit::PatternUnit()
{

}

PatternUnit::PatternUnit(const PatternUnit & other)
{

}

PatternUnit &PatternUnit::operator=(const PatternUnit & other)
{
  PatternUnit tmp(other);
  swap(tmp);
  return *this;
}

void PatternUnit::swap(PatternUnit & other)
{

}

PatternUnit::~PatternUnit()
{

}

void PatternUnit::accept(Visitor *v)
{
  v->visitPatternUnit(this);
}

PatternUnit *PatternUnit::clone() const
{
  return new PatternUnit(*this);
}



/********************   PatternInt    ********************/
PatternInt::PatternInt(Integer p1)
{
  integer_ = p1;

}

PatternInt::PatternInt(const PatternInt & other)
{
  integer_ = other.integer_;

}

PatternInt &PatternInt::operator=(const PatternInt & other)
{
  PatternInt tmp(other);
  swap(tmp);
  return *this;
}

void PatternInt::swap(PatternInt & other)
{
  std::swap(integer_, other.integer_);

}

PatternInt::~PatternInt()
{

}

void PatternInt::accept(Visitor *v)
{
  v->visitPatternInt(this);
}

PatternInt *PatternInt::clone() const
{
  return new PatternInt(*this);
}



/********************   PatternSucc    ********************/
PatternSucc::PatternSucc(Pattern *p1)
{
  pattern_ = p1;

}

PatternSucc::PatternSucc(const PatternSucc & other)
{
  pattern_ = other.pattern_->clone();

}

PatternSucc &PatternSucc::operator=(const PatternSucc & other)
{
  PatternSucc tmp(other);
  swap(tmp);
  return *this;
}

void PatternSucc::swap(PatternSucc & other)
{
  std::swap(pattern_, other.pattern_);

}

PatternSucc::~PatternSucc()
{
  delete(pattern_);

}

void PatternSucc::accept(Visitor *v)
{
  v->visitPatternSucc(this);
}

PatternSucc *PatternSucc::clone() const
{
  return new PatternSucc(*this);
}



/********************   PatternVar    ********************/
PatternVar::PatternVar(StellaIdent p1)
{
  stellaident_ = p1;

}

PatternVar::PatternVar(const PatternVar & other)
{
  stellaident_ = other.stellaident_;

}

PatternVar &PatternVar::operator=(const PatternVar & other)
{
  PatternVar tmp(other);
  swap(tmp);
  return *this;
}

void PatternVar::swap(PatternVar & other)
{
  std::swap(stellaident_, other.stellaident_);

}

PatternVar::~PatternVar()
{

}

void PatternVar::accept(Visitor *v)
{
  v->visitPatternVar(this);
}

PatternVar *PatternVar::clone() const
{
  return new PatternVar(*this);
}



/********************   ALabelledPattern    ********************/
ALabelledPattern::ALabelledPattern(StellaIdent p1, Pattern *p2)
{
  stellaident_ = p1;
  pattern_ = p2;

}

ALabelledPattern::ALabelledPattern(const ALabelledPattern & other)
{
  stellaident_ = other.stellaident_;
  pattern_ = other.pattern_->clone();

}

ALabelledPattern &ALabelledPattern::operator=(const ALabelledPattern & other)
{
  ALabelledPattern tmp(other);
  swap(tmp);
  return *this;
}

void ALabelledPattern::swap(ALabelledPattern & other)
{
  std::swap(stellaident_, other.stellaident_);
  std::swap(pattern_, other.pattern_);

}

ALabelledPattern::~ALabelledPattern()
{
  delete(pattern_);

}

void ALabelledPattern::accept(Visitor *v)
{
  v->visitALabelledPattern(this);
}

ALabelledPattern *ALabelledPattern::clone() const
{
  return new ALabelledPattern(*this);
}



/********************   ABinding    ********************/
ABinding::ABinding(StellaIdent p1, Expr *p2)
{
  stellaident_ = p1;
  expr_ = p2;

}

ABinding::ABinding(const ABinding & other)
{
  stellaident_ = other.stellaident_;
  expr_ = other.expr_->clone();

}

ABinding &ABinding::operator=(const ABinding & other)
{
  ABinding tmp(other);
  swap(tmp);
  return *this;
}

void ABinding::swap(ABinding & other)
{
  std::swap(stellaident_, other.stellaident_);
  std::swap(expr_, other.expr_);

}

ABinding::~ABinding()
{
  delete(expr_);

}

void ABinding::accept(Visitor *v)
{
  v->visitABinding(this);
}

ABinding *ABinding::clone() const
{
  return new ABinding(*this);
}



/********************   Sequence    ********************/
Sequence::Sequence(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Sequence::Sequence(const Sequence & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Sequence &Sequence::operator=(const Sequence & other)
{
  Sequence tmp(other);
  swap(tmp);
  return *this;
}

void Sequence::swap(Sequence & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Sequence::~Sequence()
{
  delete(expr_1);
  delete(expr_2);

}

void Sequence::accept(Visitor *v)
{
  v->visitSequence(this);
}

Sequence *Sequence::clone() const
{
  return new Sequence(*this);
}



/********************   If    ********************/
If::If(Expr *p1, Expr *p2, Expr *p3)
{
  expr_1 = p1;
  expr_2 = p2;
  expr_3 = p3;

}

If::If(const If & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();
  expr_3 = other.expr_3->clone();

}

If &If::operator=(const If & other)
{
  If tmp(other);
  swap(tmp);
  return *this;
}

void If::swap(If & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);
  std::swap(expr_3, other.expr_3);

}

If::~If()
{
  delete(expr_1);
  delete(expr_2);
  delete(expr_3);

}

void If::accept(Visitor *v)
{
  v->visitIf(this);
}

If *If::clone() const
{
  return new If(*this);
}



/********************   Let    ********************/
Let::Let(ListPatternBinding *p1, Expr *p2)
{
  listpatternbinding_ = p1;
  expr_ = p2;

}

Let::Let(const Let & other)
{
  listpatternbinding_ = other.listpatternbinding_->clone();
  expr_ = other.expr_->clone();

}

Let &Let::operator=(const Let & other)
{
  Let tmp(other);
  swap(tmp);
  return *this;
}

void Let::swap(Let & other)
{
  std::swap(listpatternbinding_, other.listpatternbinding_);
  std::swap(expr_, other.expr_);

}

Let::~Let()
{
  delete(listpatternbinding_);
  delete(expr_);

}

void Let::accept(Visitor *v)
{
  v->visitLet(this);
}

Let *Let::clone() const
{
  return new Let(*this);
}



/********************   LetRec    ********************/
LetRec::LetRec(ListPatternBinding *p1, Expr *p2)
{
  listpatternbinding_ = p1;
  expr_ = p2;

}

LetRec::LetRec(const LetRec & other)
{
  listpatternbinding_ = other.listpatternbinding_->clone();
  expr_ = other.expr_->clone();

}

LetRec &LetRec::operator=(const LetRec & other)
{
  LetRec tmp(other);
  swap(tmp);
  return *this;
}

void LetRec::swap(LetRec & other)
{
  std::swap(listpatternbinding_, other.listpatternbinding_);
  std::swap(expr_, other.expr_);

}

LetRec::~LetRec()
{
  delete(listpatternbinding_);
  delete(expr_);

}

void LetRec::accept(Visitor *v)
{
  v->visitLetRec(this);
}

LetRec *LetRec::clone() const
{
  return new LetRec(*this);
}



/********************   LessThan    ********************/
LessThan::LessThan(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LessThan::LessThan(const LessThan & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LessThan &LessThan::operator=(const LessThan & other)
{
  LessThan tmp(other);
  swap(tmp);
  return *this;
}

void LessThan::swap(LessThan & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LessThan::~LessThan()
{
  delete(expr_1);
  delete(expr_2);

}

void LessThan::accept(Visitor *v)
{
  v->visitLessThan(this);
}

LessThan *LessThan::clone() const
{
  return new LessThan(*this);
}



/********************   LessThanOrEqual    ********************/
LessThanOrEqual::LessThanOrEqual(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LessThanOrEqual::LessThanOrEqual(const LessThanOrEqual & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LessThanOrEqual &LessThanOrEqual::operator=(const LessThanOrEqual & other)
{
  LessThanOrEqual tmp(other);
  swap(tmp);
  return *this;
}

void LessThanOrEqual::swap(LessThanOrEqual & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LessThanOrEqual::~LessThanOrEqual()
{
  delete(expr_1);
  delete(expr_2);

}

void LessThanOrEqual::accept(Visitor *v)
{
  v->visitLessThanOrEqual(this);
}

LessThanOrEqual *LessThanOrEqual::clone() const
{
  return new LessThanOrEqual(*this);
}



/********************   GreaterThan    ********************/
GreaterThan::GreaterThan(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

GreaterThan::GreaterThan(const GreaterThan & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

GreaterThan &GreaterThan::operator=(const GreaterThan & other)
{
  GreaterThan tmp(other);
  swap(tmp);
  return *this;
}

void GreaterThan::swap(GreaterThan & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

GreaterThan::~GreaterThan()
{
  delete(expr_1);
  delete(expr_2);

}

void GreaterThan::accept(Visitor *v)
{
  v->visitGreaterThan(this);
}

GreaterThan *GreaterThan::clone() const
{
  return new GreaterThan(*this);
}



/********************   GreaterThanOrEqual    ********************/
GreaterThanOrEqual::GreaterThanOrEqual(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

GreaterThanOrEqual::GreaterThanOrEqual(const GreaterThanOrEqual & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

GreaterThanOrEqual &GreaterThanOrEqual::operator=(const GreaterThanOrEqual & other)
{
  GreaterThanOrEqual tmp(other);
  swap(tmp);
  return *this;
}

void GreaterThanOrEqual::swap(GreaterThanOrEqual & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

GreaterThanOrEqual::~GreaterThanOrEqual()
{
  delete(expr_1);
  delete(expr_2);

}

void GreaterThanOrEqual::accept(Visitor *v)
{
  v->visitGreaterThanOrEqual(this);
}

GreaterThanOrEqual *GreaterThanOrEqual::clone() const
{
  return new GreaterThanOrEqual(*this);
}



/********************   Equal    ********************/
Equal::Equal(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Equal::Equal(const Equal & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Equal &Equal::operator=(const Equal & other)
{
  Equal tmp(other);
  swap(tmp);
  return *this;
}

void Equal::swap(Equal & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Equal::~Equal()
{
  delete(expr_1);
  delete(expr_2);

}

void Equal::accept(Visitor *v)
{
  v->visitEqual(this);
}

Equal *Equal::clone() const
{
  return new Equal(*this);
}



/********************   NotEqual    ********************/
NotEqual::NotEqual(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

NotEqual::NotEqual(const NotEqual & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

NotEqual &NotEqual::operator=(const NotEqual & other)
{
  NotEqual tmp(other);
  swap(tmp);
  return *this;
}

void NotEqual::swap(NotEqual & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

NotEqual::~NotEqual()
{
  delete(expr_1);
  delete(expr_2);

}

void NotEqual::accept(Visitor *v)
{
  v->visitNotEqual(this);
}

NotEqual *NotEqual::clone() const
{
  return new NotEqual(*this);
}



/********************   TypeAsc    ********************/
TypeAsc::TypeAsc(Expr *p1, Type *p2)
{
  expr_ = p1;
  type_ = p2;

}

TypeAsc::TypeAsc(const TypeAsc & other)
{
  expr_ = other.expr_->clone();
  type_ = other.type_->clone();

}

TypeAsc &TypeAsc::operator=(const TypeAsc & other)
{
  TypeAsc tmp(other);
  swap(tmp);
  return *this;
}

void TypeAsc::swap(TypeAsc & other)
{
  std::swap(expr_, other.expr_);
  std::swap(type_, other.type_);

}

TypeAsc::~TypeAsc()
{
  delete(expr_);
  delete(type_);

}

void TypeAsc::accept(Visitor *v)
{
  v->visitTypeAsc(this);
}

TypeAsc *TypeAsc::clone() const
{
  return new TypeAsc(*this);
}



/********************   Abstraction    ********************/
Abstraction::Abstraction(ListParamDecl *p1, Expr *p2)
{
  listparamdecl_ = p1;
  expr_ = p2;

}

Abstraction::Abstraction(const Abstraction & other)
{
  listparamdecl_ = other.listparamdecl_->clone();
  expr_ = other.expr_->clone();

}

Abstraction &Abstraction::operator=(const Abstraction & other)
{
  Abstraction tmp(other);
  swap(tmp);
  return *this;
}

void Abstraction::swap(Abstraction & other)
{
  std::swap(listparamdecl_, other.listparamdecl_);
  std::swap(expr_, other.expr_);

}

Abstraction::~Abstraction()
{
  delete(listparamdecl_);
  delete(expr_);

}

void Abstraction::accept(Visitor *v)
{
  v->visitAbstraction(this);
}

Abstraction *Abstraction::clone() const
{
  return new Abstraction(*this);
}



/********************   Variant    ********************/
Variant::Variant(StellaIdent p1, ExprData *p2)
{
  stellaident_ = p1;
  exprdata_ = p2;

}

Variant::Variant(const Variant & other)
{
  stellaident_ = other.stellaident_;
  exprdata_ = other.exprdata_->clone();

}

Variant &Variant::operator=(const Variant & other)
{
  Variant tmp(other);
  swap(tmp);
  return *this;
}

void Variant::swap(Variant & other)
{
  std::swap(stellaident_, other.stellaident_);
  std::swap(exprdata_, other.exprdata_);

}

Variant::~Variant()
{
  delete(exprdata_);

}

void Variant::accept(Visitor *v)
{
  v->visitVariant(this);
}

Variant *Variant::clone() const
{
  return new Variant(*this);
}



/********************   Match    ********************/
Match::Match(Expr *p1, ListMatchCase *p2)
{
  expr_ = p1;
  listmatchcase_ = p2;

}

Match::Match(const Match & other)
{
  expr_ = other.expr_->clone();
  listmatchcase_ = other.listmatchcase_->clone();

}

Match &Match::operator=(const Match & other)
{
  Match tmp(other);
  swap(tmp);
  return *this;
}

void Match::swap(Match & other)
{
  std::swap(expr_, other.expr_);
  std::swap(listmatchcase_, other.listmatchcase_);

}

Match::~Match()
{
  delete(expr_);
  delete(listmatchcase_);

}

void Match::accept(Visitor *v)
{
  v->visitMatch(this);
}

Match *Match::clone() const
{
  return new Match(*this);
}



/********************   List    ********************/
List::List(ListExpr *p1)
{
  listexpr_ = p1;

}

List::List(const List & other)
{
  listexpr_ = other.listexpr_->clone();

}

List &List::operator=(const List & other)
{
  List tmp(other);
  swap(tmp);
  return *this;
}

void List::swap(List & other)
{
  std::swap(listexpr_, other.listexpr_);

}

List::~List()
{
  delete(listexpr_);

}

void List::accept(Visitor *v)
{
  v->visitList(this);
}

List *List::clone() const
{
  return new List(*this);
}



/********************   Add    ********************/
Add::Add(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Add::Add(const Add & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Add &Add::operator=(const Add & other)
{
  Add tmp(other);
  swap(tmp);
  return *this;
}

void Add::swap(Add & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Add::~Add()
{
  delete(expr_1);
  delete(expr_2);

}

void Add::accept(Visitor *v)
{
  v->visitAdd(this);
}

Add *Add::clone() const
{
  return new Add(*this);
}



/********************   Subtract    ********************/
Subtract::Subtract(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Subtract::Subtract(const Subtract & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Subtract &Subtract::operator=(const Subtract & other)
{
  Subtract tmp(other);
  swap(tmp);
  return *this;
}

void Subtract::swap(Subtract & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Subtract::~Subtract()
{
  delete(expr_1);
  delete(expr_2);

}

void Subtract::accept(Visitor *v)
{
  v->visitSubtract(this);
}

Subtract *Subtract::clone() const
{
  return new Subtract(*this);
}



/********************   LogicOr    ********************/
LogicOr::LogicOr(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicOr::LogicOr(const LogicOr & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicOr &LogicOr::operator=(const LogicOr & other)
{
  LogicOr tmp(other);
  swap(tmp);
  return *this;
}

void LogicOr::swap(LogicOr & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicOr::~LogicOr()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicOr::accept(Visitor *v)
{
  v->visitLogicOr(this);
}

LogicOr *LogicOr::clone() const
{
  return new LogicOr(*this);
}



/********************   Multiply    ********************/
Multiply::Multiply(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Multiply::Multiply(const Multiply & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Multiply &Multiply::operator=(const Multiply & other)
{
  Multiply tmp(other);
  swap(tmp);
  return *this;
}

void Multiply::swap(Multiply & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Multiply::~Multiply()
{
  delete(expr_1);
  delete(expr_2);

}

void Multiply::accept(Visitor *v)
{
  v->visitMultiply(this);
}

Multiply *Multiply::clone() const
{
  return new Multiply(*this);
}



/********************   Divide    ********************/
Divide::Divide(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Divide::Divide(const Divide & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Divide &Divide::operator=(const Divide & other)
{
  Divide tmp(other);
  swap(tmp);
  return *this;
}

void Divide::swap(Divide & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Divide::~Divide()
{
  delete(expr_1);
  delete(expr_2);

}

void Divide::accept(Visitor *v)
{
  v->visitDivide(this);
}

Divide *Divide::clone() const
{
  return new Divide(*this);
}



/********************   LogicAnd    ********************/
LogicAnd::LogicAnd(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicAnd::LogicAnd(const LogicAnd & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicAnd &LogicAnd::operator=(const LogicAnd & other)
{
  LogicAnd tmp(other);
  swap(tmp);
  return *this;
}

void LogicAnd::swap(LogicAnd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicAnd::~LogicAnd()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicAnd::accept(Visitor *v)
{
  v->visitLogicAnd(this);
}

LogicAnd *LogicAnd::clone() const
{
  return new LogicAnd(*this);
}



/********************   Application    ********************/
Application::Application(Expr *p1, ListExpr *p2)
{
  expr_ = p1;
  listexpr_ = p2;

}

Application::Application(const Application & other)
{
  expr_ = other.expr_->clone();
  listexpr_ = other.listexpr_->clone();

}

Application &Application::operator=(const Application & other)
{
  Application tmp(other);
  swap(tmp);
  return *this;
}

void Application::swap(Application & other)
{
  std::swap(expr_, other.expr_);
  std::swap(listexpr_, other.listexpr_);

}

Application::~Application()
{
  delete(expr_);
  delete(listexpr_);

}

void Application::accept(Visitor *v)
{
  v->visitApplication(this);
}

Application *Application::clone() const
{
  return new Application(*this);
}



/********************   DotRecord    ********************/
DotRecord::DotRecord(Expr *p1, StellaIdent p2)
{
  expr_ = p1;
  stellaident_ = p2;

}

DotRecord::DotRecord(const DotRecord & other)
{
  expr_ = other.expr_->clone();
  stellaident_ = other.stellaident_;

}

DotRecord &DotRecord::operator=(const DotRecord & other)
{
  DotRecord tmp(other);
  swap(tmp);
  return *this;
}

void DotRecord::swap(DotRecord & other)
{
  std::swap(expr_, other.expr_);
  std::swap(stellaident_, other.stellaident_);

}

DotRecord::~DotRecord()
{
  delete(expr_);

}

void DotRecord::accept(Visitor *v)
{
  v->visitDotRecord(this);
}

DotRecord *DotRecord::clone() const
{
  return new DotRecord(*this);
}



/********************   DotTuple    ********************/
DotTuple::DotTuple(Expr *p1, Integer p2)
{
  expr_ = p1;
  integer_ = p2;

}

DotTuple::DotTuple(const DotTuple & other)
{
  expr_ = other.expr_->clone();
  integer_ = other.integer_;

}

DotTuple &DotTuple::operator=(const DotTuple & other)
{
  DotTuple tmp(other);
  swap(tmp);
  return *this;
}

void DotTuple::swap(DotTuple & other)
{
  std::swap(expr_, other.expr_);
  std::swap(integer_, other.integer_);

}

DotTuple::~DotTuple()
{
  delete(expr_);

}

void DotTuple::accept(Visitor *v)
{
  v->visitDotTuple(this);
}

DotTuple *DotTuple::clone() const
{
  return new DotTuple(*this);
}



/********************   Tuple    ********************/
Tuple::Tuple(ListExpr *p1)
{
  listexpr_ = p1;

}

Tuple::Tuple(const Tuple & other)
{
  listexpr_ = other.listexpr_->clone();

}

Tuple &Tuple::operator=(const Tuple & other)
{
  Tuple tmp(other);
  swap(tmp);
  return *this;
}

void Tuple::swap(Tuple & other)
{
  std::swap(listexpr_, other.listexpr_);

}

Tuple::~Tuple()
{
  delete(listexpr_);

}

void Tuple::accept(Visitor *v)
{
  v->visitTuple(this);
}

Tuple *Tuple::clone() const
{
  return new Tuple(*this);
}



/********************   Record    ********************/
Record::Record(ListBinding *p1)
{
  listbinding_ = p1;

}

Record::Record(const Record & other)
{
  listbinding_ = other.listbinding_->clone();

}

Record &Record::operator=(const Record & other)
{
  Record tmp(other);
  swap(tmp);
  return *this;
}

void Record::swap(Record & other)
{
  std::swap(listbinding_, other.listbinding_);

}

Record::~Record()
{
  delete(listbinding_);

}

void Record::accept(Visitor *v)
{
  v->visitRecord(this);
}

Record *Record::clone() const
{
  return new Record(*this);
}



/********************   ConsList    ********************/
ConsList::ConsList(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

ConsList::ConsList(const ConsList & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

ConsList &ConsList::operator=(const ConsList & other)
{
  ConsList tmp(other);
  swap(tmp);
  return *this;
}

void ConsList::swap(ConsList & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

ConsList::~ConsList()
{
  delete(expr_1);
  delete(expr_2);

}

void ConsList::accept(Visitor *v)
{
  v->visitConsList(this);
}

ConsList *ConsList::clone() const
{
  return new ConsList(*this);
}



/********************   Head    ********************/
Head::Head(Expr *p1)
{
  expr_ = p1;

}

Head::Head(const Head & other)
{
  expr_ = other.expr_->clone();

}

Head &Head::operator=(const Head & other)
{
  Head tmp(other);
  swap(tmp);
  return *this;
}

void Head::swap(Head & other)
{
  std::swap(expr_, other.expr_);

}

Head::~Head()
{
  delete(expr_);

}

void Head::accept(Visitor *v)
{
  v->visitHead(this);
}

Head *Head::clone() const
{
  return new Head(*this);
}



/********************   IsEmpty    ********************/
IsEmpty::IsEmpty(Expr *p1)
{
  expr_ = p1;

}

IsEmpty::IsEmpty(const IsEmpty & other)
{
  expr_ = other.expr_->clone();

}

IsEmpty &IsEmpty::operator=(const IsEmpty & other)
{
  IsEmpty tmp(other);
  swap(tmp);
  return *this;
}

void IsEmpty::swap(IsEmpty & other)
{
  std::swap(expr_, other.expr_);

}

IsEmpty::~IsEmpty()
{
  delete(expr_);

}

void IsEmpty::accept(Visitor *v)
{
  v->visitIsEmpty(this);
}

IsEmpty *IsEmpty::clone() const
{
  return new IsEmpty(*this);
}



/********************   Tail    ********************/
Tail::Tail(Expr *p1)
{
  expr_ = p1;

}

Tail::Tail(const Tail & other)
{
  expr_ = other.expr_->clone();

}

Tail &Tail::operator=(const Tail & other)
{
  Tail tmp(other);
  swap(tmp);
  return *this;
}

void Tail::swap(Tail & other)
{
  std::swap(expr_, other.expr_);

}

Tail::~Tail()
{
  delete(expr_);

}

void Tail::accept(Visitor *v)
{
  v->visitTail(this);
}

Tail *Tail::clone() const
{
  return new Tail(*this);
}



/********************   Inl    ********************/
Inl::Inl(Expr *p1)
{
  expr_ = p1;

}

Inl::Inl(const Inl & other)
{
  expr_ = other.expr_->clone();

}

Inl &Inl::operator=(const Inl & other)
{
  Inl tmp(other);
  swap(tmp);
  return *this;
}

void Inl::swap(Inl & other)
{
  std::swap(expr_, other.expr_);

}

Inl::~Inl()
{
  delete(expr_);

}

void Inl::accept(Visitor *v)
{
  v->visitInl(this);
}

Inl *Inl::clone() const
{
  return new Inl(*this);
}



/********************   Inr    ********************/
Inr::Inr(Expr *p1)
{
  expr_ = p1;

}

Inr::Inr(const Inr & other)
{
  expr_ = other.expr_->clone();

}

Inr &Inr::operator=(const Inr & other)
{
  Inr tmp(other);
  swap(tmp);
  return *this;
}

void Inr::swap(Inr & other)
{
  std::swap(expr_, other.expr_);

}

Inr::~Inr()
{
  delete(expr_);

}

void Inr::accept(Visitor *v)
{
  v->visitInr(this);
}

Inr *Inr::clone() const
{
  return new Inr(*this);
}



/********************   Succ    ********************/
Succ::Succ(Expr *p1)
{
  expr_ = p1;

}

Succ::Succ(const Succ & other)
{
  expr_ = other.expr_->clone();

}

Succ &Succ::operator=(const Succ & other)
{
  Succ tmp(other);
  swap(tmp);
  return *this;
}

void Succ::swap(Succ & other)
{
  std::swap(expr_, other.expr_);

}

Succ::~Succ()
{
  delete(expr_);

}

void Succ::accept(Visitor *v)
{
  v->visitSucc(this);
}

Succ *Succ::clone() const
{
  return new Succ(*this);
}



/********************   LogicNot    ********************/
LogicNot::LogicNot(Expr *p1)
{
  expr_ = p1;

}

LogicNot::LogicNot(const LogicNot & other)
{
  expr_ = other.expr_->clone();

}

LogicNot &LogicNot::operator=(const LogicNot & other)
{
  LogicNot tmp(other);
  swap(tmp);
  return *this;
}

void LogicNot::swap(LogicNot & other)
{
  std::swap(expr_, other.expr_);

}

LogicNot::~LogicNot()
{
  delete(expr_);

}

void LogicNot::accept(Visitor *v)
{
  v->visitLogicNot(this);
}

LogicNot *LogicNot::clone() const
{
  return new LogicNot(*this);
}



/********************   Pred    ********************/
Pred::Pred(Expr *p1)
{
  expr_ = p1;

}

Pred::Pred(const Pred & other)
{
  expr_ = other.expr_->clone();

}

Pred &Pred::operator=(const Pred & other)
{
  Pred tmp(other);
  swap(tmp);
  return *this;
}

void Pred::swap(Pred & other)
{
  std::swap(expr_, other.expr_);

}

Pred::~Pred()
{
  delete(expr_);

}

void Pred::accept(Visitor *v)
{
  v->visitPred(this);
}

Pred *Pred::clone() const
{
  return new Pred(*this);
}



/********************   IsZero    ********************/
IsZero::IsZero(Expr *p1)
{
  expr_ = p1;

}

IsZero::IsZero(const IsZero & other)
{
  expr_ = other.expr_->clone();

}

IsZero &IsZero::operator=(const IsZero & other)
{
  IsZero tmp(other);
  swap(tmp);
  return *this;
}

void IsZero::swap(IsZero & other)
{
  std::swap(expr_, other.expr_);

}

IsZero::~IsZero()
{
  delete(expr_);

}

void IsZero::accept(Visitor *v)
{
  v->visitIsZero(this);
}

IsZero *IsZero::clone() const
{
  return new IsZero(*this);
}



/********************   Fix    ********************/
Fix::Fix(Expr *p1)
{
  expr_ = p1;

}

Fix::Fix(const Fix & other)
{
  expr_ = other.expr_->clone();

}

Fix &Fix::operator=(const Fix & other)
{
  Fix tmp(other);
  swap(tmp);
  return *this;
}

void Fix::swap(Fix & other)
{
  std::swap(expr_, other.expr_);

}

Fix::~Fix()
{
  delete(expr_);

}

void Fix::accept(Visitor *v)
{
  v->visitFix(this);
}

Fix *Fix::clone() const
{
  return new Fix(*this);
}



/********************   NatRec    ********************/
NatRec::NatRec(Expr *p1, Expr *p2, Expr *p3)
{
  expr_1 = p1;
  expr_2 = p2;
  expr_3 = p3;

}

NatRec::NatRec(const NatRec & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();
  expr_3 = other.expr_3->clone();

}

NatRec &NatRec::operator=(const NatRec & other)
{
  NatRec tmp(other);
  swap(tmp);
  return *this;
}

void NatRec::swap(NatRec & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);
  std::swap(expr_3, other.expr_3);

}

NatRec::~NatRec()
{
  delete(expr_1);
  delete(expr_2);
  delete(expr_3);

}

void NatRec::accept(Visitor *v)
{
  v->visitNatRec(this);
}

NatRec *NatRec::clone() const
{
  return new NatRec(*this);
}



/********************   Fold    ********************/
Fold::Fold(Type *p1, Expr *p2)
{
  type_ = p1;
  expr_ = p2;

}

Fold::Fold(const Fold & other)
{
  type_ = other.type_->clone();
  expr_ = other.expr_->clone();

}

Fold &Fold::operator=(const Fold & other)
{
  Fold tmp(other);
  swap(tmp);
  return *this;
}

void Fold::swap(Fold & other)
{
  std::swap(type_, other.type_);
  std::swap(expr_, other.expr_);

}

Fold::~Fold()
{
  delete(type_);
  delete(expr_);

}

void Fold::accept(Visitor *v)
{
  v->visitFold(this);
}

Fold *Fold::clone() const
{
  return new Fold(*this);
}



/********************   Unfold    ********************/
Unfold::Unfold(Type *p1, Expr *p2)
{
  type_ = p1;
  expr_ = p2;

}

Unfold::Unfold(const Unfold & other)
{
  type_ = other.type_->clone();
  expr_ = other.expr_->clone();

}

Unfold &Unfold::operator=(const Unfold & other)
{
  Unfold tmp(other);
  swap(tmp);
  return *this;
}

void Unfold::swap(Unfold & other)
{
  std::swap(type_, other.type_);
  std::swap(expr_, other.expr_);

}

Unfold::~Unfold()
{
  delete(type_);
  delete(expr_);

}

void Unfold::accept(Visitor *v)
{
  v->visitUnfold(this);
}

Unfold *Unfold::clone() const
{
  return new Unfold(*this);
}



/********************   ConstTrue    ********************/
ConstTrue::ConstTrue()
{

}

ConstTrue::ConstTrue(const ConstTrue & other)
{

}

ConstTrue &ConstTrue::operator=(const ConstTrue & other)
{
  ConstTrue tmp(other);
  swap(tmp);
  return *this;
}

void ConstTrue::swap(ConstTrue & other)
{

}

ConstTrue::~ConstTrue()
{

}

void ConstTrue::accept(Visitor *v)
{
  v->visitConstTrue(this);
}

ConstTrue *ConstTrue::clone() const
{
  return new ConstTrue(*this);
}



/********************   ConstFalse    ********************/
ConstFalse::ConstFalse()
{

}

ConstFalse::ConstFalse(const ConstFalse & other)
{

}

ConstFalse &ConstFalse::operator=(const ConstFalse & other)
{
  ConstFalse tmp(other);
  swap(tmp);
  return *this;
}

void ConstFalse::swap(ConstFalse & other)
{

}

ConstFalse::~ConstFalse()
{

}

void ConstFalse::accept(Visitor *v)
{
  v->visitConstFalse(this);
}

ConstFalse *ConstFalse::clone() const
{
  return new ConstFalse(*this);
}



/********************   ConstUnit    ********************/
ConstUnit::ConstUnit()
{

}

ConstUnit::ConstUnit(const ConstUnit & other)
{

}

ConstUnit &ConstUnit::operator=(const ConstUnit & other)
{
  ConstUnit tmp(other);
  swap(tmp);
  return *this;
}

void ConstUnit::swap(ConstUnit & other)
{

}

ConstUnit::~ConstUnit()
{

}

void ConstUnit::accept(Visitor *v)
{
  v->visitConstUnit(this);
}

ConstUnit *ConstUnit::clone() const
{
  return new ConstUnit(*this);
}



/********************   ConstInt    ********************/
ConstInt::ConstInt(Integer p1)
{
  integer_ = p1;

}

ConstInt::ConstInt(const ConstInt & other)
{
  integer_ = other.integer_;

}

ConstInt &ConstInt::operator=(const ConstInt & other)
{
  ConstInt tmp(other);
  swap(tmp);
  return *this;
}

void ConstInt::swap(ConstInt & other)
{
  std::swap(integer_, other.integer_);

}

ConstInt::~ConstInt()
{

}

void ConstInt::accept(Visitor *v)
{
  v->visitConstInt(this);
}

ConstInt *ConstInt::clone() const
{
  return new ConstInt(*this);
}



/********************   Var    ********************/
Var::Var(StellaIdent p1)
{
  stellaident_ = p1;

}

Var::Var(const Var & other)
{
  stellaident_ = other.stellaident_;

}

Var &Var::operator=(const Var & other)
{
  Var tmp(other);
  swap(tmp);
  return *this;
}

void Var::swap(Var & other)
{
  std::swap(stellaident_, other.stellaident_);

}

Var::~Var()
{

}

void Var::accept(Visitor *v)
{
  v->visitVar(this);
}

Var *Var::clone() const
{
  return new Var(*this);
}



/********************   APatternBinding    ********************/
APatternBinding::APatternBinding(Pattern *p1, Expr *p2)
{
  pattern_ = p1;
  expr_ = p2;

}

APatternBinding::APatternBinding(const APatternBinding & other)
{
  pattern_ = other.pattern_->clone();
  expr_ = other.expr_->clone();

}

APatternBinding &APatternBinding::operator=(const APatternBinding & other)
{
  APatternBinding tmp(other);
  swap(tmp);
  return *this;
}

void APatternBinding::swap(APatternBinding & other)
{
  std::swap(pattern_, other.pattern_);
  std::swap(expr_, other.expr_);

}

APatternBinding::~APatternBinding()
{
  delete(pattern_);
  delete(expr_);

}

void APatternBinding::accept(Visitor *v)
{
  v->visitAPatternBinding(this);
}

APatternBinding *APatternBinding::clone() const
{
  return new APatternBinding(*this);
}



/********************   AVariantFieldType    ********************/
AVariantFieldType::AVariantFieldType(StellaIdent p1, OptionalTyping *p2)
{
  stellaident_ = p1;
  optionaltyping_ = p2;

}

AVariantFieldType::AVariantFieldType(const AVariantFieldType & other)
{
  stellaident_ = other.stellaident_;
  optionaltyping_ = other.optionaltyping_->clone();

}

AVariantFieldType &AVariantFieldType::operator=(const AVariantFieldType & other)
{
  AVariantFieldType tmp(other);
  swap(tmp);
  return *this;
}

void AVariantFieldType::swap(AVariantFieldType & other)
{
  std::swap(stellaident_, other.stellaident_);
  std::swap(optionaltyping_, other.optionaltyping_);

}

AVariantFieldType::~AVariantFieldType()
{
  delete(optionaltyping_);

}

void AVariantFieldType::accept(Visitor *v)
{
  v->visitAVariantFieldType(this);
}

AVariantFieldType *AVariantFieldType::clone() const
{
  return new AVariantFieldType(*this);
}



/********************   ARecordFieldType    ********************/
ARecordFieldType::ARecordFieldType(StellaIdent p1, Type *p2)
{
  stellaident_ = p1;
  type_ = p2;

}

ARecordFieldType::ARecordFieldType(const ARecordFieldType & other)
{
  stellaident_ = other.stellaident_;
  type_ = other.type_->clone();

}

ARecordFieldType &ARecordFieldType::operator=(const ARecordFieldType & other)
{
  ARecordFieldType tmp(other);
  swap(tmp);
  return *this;
}

void ARecordFieldType::swap(ARecordFieldType & other)
{
  std::swap(stellaident_, other.stellaident_);
  std::swap(type_, other.type_);

}

ARecordFieldType::~ARecordFieldType()
{
  delete(type_);

}

void ARecordFieldType::accept(Visitor *v)
{
  v->visitARecordFieldType(this);
}

ARecordFieldType *ARecordFieldType::clone() const
{
  return new ARecordFieldType(*this);
}



/********************   ATyping    ********************/
ATyping::ATyping(Expr *p1, Type *p2)
{
  expr_ = p1;
  type_ = p2;

}

ATyping::ATyping(const ATyping & other)
{
  expr_ = other.expr_->clone();
  type_ = other.type_->clone();

}

ATyping &ATyping::operator=(const ATyping & other)
{
  ATyping tmp(other);
  swap(tmp);
  return *this;
}

void ATyping::swap(ATyping & other)
{
  std::swap(expr_, other.expr_);
  std::swap(type_, other.type_);

}

ATyping::~ATyping()
{
  delete(expr_);
  delete(type_);

}

void ATyping::accept(Visitor *v)
{
  v->visitATyping(this);
}

ATyping *ATyping::clone() const
{
  return new ATyping(*this);
}




/********************   ListStellaIdent    ********************/

void ListStellaIdent::accept(Visitor *v)
{
  v->visitListStellaIdent(this);
}

ListStellaIdent *ListStellaIdent::clone() const
{
  return new ListStellaIdent(*this);
}

ListStellaIdent* consListStellaIdent(StellaIdent x, ListStellaIdent* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExtensionName    ********************/

void ListExtensionName::accept(Visitor *v)
{
  v->visitListExtensionName(this);
}

ListExtensionName *ListExtensionName::clone() const
{
  return new ListExtensionName(*this);
}

ListExtensionName* consListExtensionName(ExtensionName x, ListExtensionName* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExtension    ********************/

void ListExtension::accept(Visitor *v)
{
  v->visitListExtension(this);
}

ListExtension *ListExtension::clone() const
{
  return new ListExtension(*this);
}

ListExtension* consListExtension(Extension* x, ListExtension* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListDecl    ********************/

void ListDecl::accept(Visitor *v)
{
  v->visitListDecl(this);
}

ListDecl *ListDecl::clone() const
{
  return new ListDecl(*this);
}

ListDecl* consListDecl(Decl* x, ListDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLocalDecl    ********************/

void ListLocalDecl::accept(Visitor *v)
{
  v->visitListLocalDecl(this);
}

ListLocalDecl *ListLocalDecl::clone() const
{
  return new ListLocalDecl(*this);
}

ListLocalDecl* consListLocalDecl(LocalDecl* x, ListLocalDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAnnotation    ********************/

void ListAnnotation::accept(Visitor *v)
{
  v->visitListAnnotation(this);
}

ListAnnotation *ListAnnotation::clone() const
{
  return new ListAnnotation(*this);
}

ListAnnotation* consListAnnotation(Annotation* x, ListAnnotation* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListParamDecl    ********************/

void ListParamDecl::accept(Visitor *v)
{
  v->visitListParamDecl(this);
}

ListParamDecl *ListParamDecl::clone() const
{
  return new ListParamDecl(*this);
}

ListParamDecl* consListParamDecl(ParamDecl* x, ListParamDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListType    ********************/

void ListType::accept(Visitor *v)
{
  v->visitListType(this);
}

ListType *ListType::clone() const
{
  return new ListType(*this);
}

ListType* consListType(Type* x, ListType* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListMatchCase    ********************/

void ListMatchCase::accept(Visitor *v)
{
  v->visitListMatchCase(this);
}

ListMatchCase *ListMatchCase::clone() const
{
  return new ListMatchCase(*this);
}

ListMatchCase* consListMatchCase(MatchCase* x, ListMatchCase* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListPattern    ********************/

void ListPattern::accept(Visitor *v)
{
  v->visitListPattern(this);
}

ListPattern *ListPattern::clone() const
{
  return new ListPattern(*this);
}

ListPattern* consListPattern(Pattern* x, ListPattern* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLabelledPattern    ********************/

void ListLabelledPattern::accept(Visitor *v)
{
  v->visitListLabelledPattern(this);
}

ListLabelledPattern *ListLabelledPattern::clone() const
{
  return new ListLabelledPattern(*this);
}

ListLabelledPattern* consListLabelledPattern(LabelledPattern* x, ListLabelledPattern* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListBinding    ********************/

void ListBinding::accept(Visitor *v)
{
  v->visitListBinding(this);
}

ListBinding *ListBinding::clone() const
{
  return new ListBinding(*this);
}

ListBinding* consListBinding(Binding* x, ListBinding* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExpr    ********************/

void ListExpr::accept(Visitor *v)
{
  v->visitListExpr(this);
}

ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}

ListExpr* consListExpr(Expr* x, ListExpr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListPatternBinding    ********************/

void ListPatternBinding::accept(Visitor *v)
{
  v->visitListPatternBinding(this);
}

ListPatternBinding *ListPatternBinding::clone() const
{
  return new ListPatternBinding(*this);
}

ListPatternBinding* consListPatternBinding(PatternBinding* x, ListPatternBinding* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListVariantFieldType    ********************/

void ListVariantFieldType::accept(Visitor *v)
{
  v->visitListVariantFieldType(this);
}

ListVariantFieldType *ListVariantFieldType::clone() const
{
  return new ListVariantFieldType(*this);
}

ListVariantFieldType* consListVariantFieldType(VariantFieldType* x, ListVariantFieldType* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListRecordFieldType    ********************/

void ListRecordFieldType::accept(Visitor *v)
{
  v->visitListRecordFieldType(this);
}

ListRecordFieldType *ListRecordFieldType::clone() const
{
  return new ListRecordFieldType(*this);
}

ListRecordFieldType* consListRecordFieldType(RecordFieldType* x, ListRecordFieldType* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}




}
